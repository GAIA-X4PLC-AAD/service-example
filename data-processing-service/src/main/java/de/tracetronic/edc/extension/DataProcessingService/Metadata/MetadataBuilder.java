// SPDX-FileCopyrightText: 2024 tracetronic GmbH
//
// SPDX-License-Identifier: Apache-2.0

package de.tracetronic.edc.extension.DataProcessingService.Metadata;

import java.util.List;

import org.eclipse.edc.spi.monitor.Monitor;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import de.tracetronic.edc.extension.DataProcessingService.Requests.ServiceMetadataRequest;
import de.tracetronic.edc.extension.DataProcessingService.Requests.ServiceMetadataRequest.RequiredFile;
import de.tracetronic.edc.extension.DataProcessingService.Requests.ServiceMetadataRequest.ResultingFile;

/**
 * This class is used to build the service metadata
 */
class MetadataBuilder {

    // Mapper to handle JSON
    private final ObjectMapper MAPPER = new ObjectMapper();

    private final Monitor monitor;

    // Parsed id if the claims
    private String claimId;

    MetadataBuilder (Monitor monitor) {
        this.monitor = monitor;
    }
    
    /** 
     * This method adjusts the claims that are generated by the CCP
     * @param serviceMetadataRequest Request object provided by the user
     * @param generatedClaims Claims generated by the CCP
     * @param credentialList The list of the needed credentials
     * @return JsonNode that represents all adjusted claims
     */
    JsonNode adjustClaims(ServiceMetadataRequest serviceMetadataRequest, String generatedClaims, List<String> credentialList) {
        JsonNode rootNode;
        try {
            rootNode = MAPPER.readTree(generatedClaims);
            ArrayNode node = (ArrayNode) rootNode;
            //Adjust all the given classes
            node.elements().forEachRemaining(childNode -> {
                String type = childNode.get("@type").asText();
                switch (type) {
                    case "gx:PhysicalResource":
                        ((ObjectNode) childNode.get("gx:location")).put("@value", serviceMetadataRequest.getPhysResLocation());
                        ((ObjectNode) childNode.get("gx:name")).put("@value", serviceMetadataRequest.getPhysResName());
                        ((ObjectNode) childNode.get("gx:description")).put("@value", serviceMetadataRequest.getPhysResDescription());
                        break;
                    case "gx:ServiceAccessPoint":
                        ((ObjectNode) childNode.get("gx:name")).put("@value", serviceMetadataRequest.getSeAcPoName());
                        ((ObjectNode) childNode.get("gx:host")).put("@value", serviceMetadataRequest.getSeAcPoHost());
                        ((ObjectNode) childNode.get("gx:protocol")).put("@value", serviceMetadataRequest.getSeAcPoProtocol());
                        ((ObjectNode) childNode.get("gx:version")).put("@value", serviceMetadataRequest.getSeAcPoVersion());
                        ((ObjectNode) childNode.get("gx:port")).put("@value", serviceMetadataRequest.getSeAcPoPort());
                        ((ObjectNode) childNode.get("gx:openAPI")).put("@value", serviceMetadataRequest.getSeAcPoOpenAPI());
                        break;
                    case "gx:DataResource":
                        adjustDataResourceToSoftwareResource(childNode, serviceMetadataRequest);
                        break;
                    case "gx:InstantiatedVirtualResource":
                        ((ObjectNode) childNode.get("gx:instanceOf")).put("id", childNode.get("gx:instanceOf").get("id").asText().replace("data-resource", "software-resource"));
                        break;
                    case "gx:ServiceOffering":
                        break;
                }
            });
        } catch (JsonProcessingException e) {
            monitor.severe("Error while adjusting the generated claims");;
            return null;
        }
        //Add the service specific metadata
        JsonNode serviceNode = createServiceMetadata(serviceMetadataRequest);
        ((ArrayNode) rootNode).add(serviceNode);

        //Create a new node for restructuring to fit the CCP endpoint
        ObjectNode newNode = MAPPER.createObjectNode();
        //Append the old node with all the claims to the new node
        newNode.set("claims", rootNode);
        //Parse all credentials from their string and put them in an array node
        ArrayNode credentialArrayNode = MAPPER.createArrayNode();
        for (String credential : credentialList) {
            try {
                JsonNode node = MAPPER.readTree(credential);
                credentialArrayNode.add(node);
            } catch (JsonProcessingException e) {
                monitor.severe("Error parsing valid json from the credentials");
                return null;
            }
        }
        //Append the credentials
        newNode.set("verifiableCredentials", credentialArrayNode);
        return newNode;
    }

    /**
     * Convert the data resource provided by the CCP to a software resource.
     * @param childNode node of the data resource
     * @param serviceMetadataRequest Request object provided by the user
     * @return nothing, since the given objects is altered instead
     */
    private void adjustDataResourceToSoftwareResource(JsonNode childNode, ServiceMetadataRequest serviceMetadataRequest) {
        String foundIdString = childNode.get("@id").asText();

        int lastSlashIndex = foundIdString.lastIndexOf('/');
        claimId = foundIdString.substring(lastSlashIndex + 1);
        ((ObjectNode) childNode).put("@type", "gx:SoftwareResource");
        ((ObjectNode) childNode).put("@id", childNode.get("@id").asText().replace("data-resource", "software-resource"));
        ((ObjectNode) childNode).remove("gx:containsPII");
        ((ObjectNode) childNode).remove("gx:producedBy");
        ((ObjectNode) childNode.get("gx:name")).put("@value", serviceMetadataRequest.getSoftResName());
        ((ObjectNode) childNode.get("gx:description")).put("@value", serviceMetadataRequest.getSoftResDescription());
    }

    /**
     * Creates the service-specific metadata
     * @param serviceMetadataRequest Request object provided by the user
     * @return the service metadata as a JsonNode
     */
    private JsonNode createServiceMetadata(ServiceMetadataRequest serviceMetadataRequest) {
        //Use the metadata template and fill it with the relevant information
        String result = String.format(
            SERVICE_METADATA_TEMPLATE, 
            serviceMetadataRequest.getIdentifierPrefix(),
            this.claimId,
            serviceMetadataRequest.getServiceName(), 
            serviceMetadataRequest.getServiceDescription(), 
            serviceMetadataRequest.getServiceContractId());

        try {
            ObjectNode serviceNode = (ObjectNode) MAPPER.readTree(result);
            //Create the requiredFiles metadata
            ArrayNode requiredFilesArrayNode = MAPPER.createArrayNode();
            for (RequiredFile file : serviceMetadataRequest.getRequiredFiles()) {
                ObjectNode node = createObjectNode("service:RequiredFile");
                node.set("service:description", createObjectNode("xsd:string", file.getDescription()));
                node.set("service:specification", createObjectNode("xsd:anyURI", file.getSpecification()));
                if (file.getTooling() != null) {
                    node.set("service:tooling", createObjectNode("xsd:anyURI", file.getTooling()));
                }
                requiredFilesArrayNode.add(node);
            }
            serviceNode.set("service:requiredFile", requiredFilesArrayNode);
            //Create the resultingFiles metadata
            ArrayNode resultingFilesArrayNode = MAPPER.createArrayNode();
            for (ResultingFile file : serviceMetadataRequest.getResultingFiles()) {
                ObjectNode node = createObjectNode("service:ResultingFile");
                node.set("service:description", createObjectNode("xsd:string", file.getDescription()));
                node.set("service:specification", createObjectNode("xsd:anyURI", file.getSpecification()));
                resultingFilesArrayNode.add(node);
            }
            serviceNode.set("service:resultingFile", resultingFilesArrayNode);

            return serviceNode;
        } catch (JsonProcessingException e) {
            monitor.severe("Error while creating the requiredFile/resultingFile Metadata");
            return null;
        }
    }

    /**
     * Helper method to create an object node
     */
    private ObjectNode createObjectNode(String type) {
        ObjectNode node = MAPPER.createObjectNode();
        node.put("@type", type);
        return node;
    }

    /**
     * Helper method to create an object node
     */
    private ObjectNode createObjectNode(String type, String value) {
        ObjectNode node = createObjectNode(type);
        node.put("@value", value);
        return node;
    }

    // String that represents a part of the service metadata. Is a template that contains fields which can be filled
    private final String SERVICE_METADATA_TEMPLATE = """
{
    "@context": {
        "general": "https://github.com/GAIA-X4PLC-AAD/ontology-management-base/tree/main/general/",
        "gx": "https://registry.lab.gaia-x.eu/development/api/trusted-shape-registry/v1/shapes/jsonld/trustframework#",
        "service": "https://github.com/GAIA-X4PLC-AAD/ontology-management-base/tree/main/service/",
        "sh": "http://www.w3.org/ns/shacl#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",
        "skos": "http://www.w3.org/2004/02/skos/core#"
    },
    "@id": "%s/software-resource/%s",
    "@type": "service:Service",
    "service:general": {
        "@type": "general:General",
        "general:description": {
        "@type": "general:Description",
        "gx:name": {
            "@value": "%s",
            "@type": "xsd:string"
        },
        "gx:description": {
            "@value": "%s",
            "@type": "xsd:string"
        }
        },
        "general:data": {
        "@type": "general:Data",
        "general:size": {
            "@value": "0.0",
            "@type": "xsd:float"
        },
        "general:contractId": {
            "@value": "%s",
            "@type": "xsd:string"
        },
        "general:recordingTime": {
            "@value": "2024-08-19T18:05:00",
            "@type": "xsd:dateTime"
        }
        },
        "general:links": {
        "@type": "general:Links",
        "general:data": {
            "@type": "general:Link",
            "general:url": {
            "@value": "https://example.org/",
            "@type": "xsd:anyURI"
            },
            "general:type": "Asset"
        }
        }
    }
}
                """;
    
}
